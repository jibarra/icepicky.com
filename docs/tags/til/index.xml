<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Til on Jose Ibarra</title><link>//www.icepicky.com/tags/til/</link><description>Recent content in Til on Jose Ibarra</description><generator>Hugo</generator><language>en-US</language><lastBuildDate>Wed, 08 Nov 2023 15:44:43 -0700</lastBuildDate><atom:link href="//www.icepicky.com/tags/til/index.xml" rel="self" type="application/rss+xml"/><item><title>TIL: Git Force With Lease</title><link>//www.icepicky.com/blog/til-git-force-with-lease/</link><pubDate>Wed, 08 Nov 2023 15:44:43 -0700</pubDate><guid>//www.icepicky.com/blog/til-git-force-with-lease/</guid><description>&lt;p>Today I learned about &lt;a href="https://git-scm.com/docs/git-push#Documentation/git-push.txt---force-with-leaseltrefnamegt" target="_blank" rel="noopener">the Git &lt;code>--force-with-lease&lt;/code> command.&lt;/a> &lt;/p>
&lt;p>I&amp;rsquo;ll restate a description of the command but it allows you to rebase and force push with less risks than using &lt;code>--force&lt;/code>. If you had pushed your changes up to a remote branch and somebody else had pushed up new changes to that remote branch while you&amp;rsquo;re rebasing. After you finish rebasing, a normal &lt;code>git push&lt;/code> will fail because the local refs don&amp;rsquo;t match the remote ones. Usually people will &lt;code>git push --force&lt;/code> at this point because they were just rebasing their branch. However, this would wipe away commits on the remote branch. This is easy to do if you&amp;rsquo;re working on a branch and don&amp;rsquo;t realize that somebody else had commit to it.&lt;/p></description></item><item><title>TIL: SQL DISTINCT Efficiency</title><link>//www.icepicky.com/blog/til-sql-distinct-efficiency/</link><pubDate>Tue, 07 Nov 2023 16:35:46 -0700</pubDate><guid>//www.icepicky.com/blog/til-sql-distinct-efficiency/</guid><description>&lt;p>Today I learned that &lt;code>DISTINCT&lt;/code> statements can cause efficiency problems.&lt;/p>
&lt;p>I was looking at some code that made a few joins across tables and used distinct for the column names. The query was causing high CPU load and it wasn&amp;rsquo;t immediately obvious from first glance why that was happening. You could imagine the query looked like this (with a few more joins and selects):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">SELECT&lt;/span> &lt;span style="color:#66d9ef">DISTINCT&lt;/span> transactions.date, transactions.total_amount, transaction_items.amount, transaction_items.name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">FROM&lt;/span> transactions
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">INNER&lt;/span> &lt;span style="color:#66d9ef">JOIN&lt;/span> transaction_items &lt;span style="color:#66d9ef">ON&lt;/span> transaction_items.transaction_id &lt;span style="color:#f92672">=&lt;/span> transactions.id
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">WHERE&lt;/span> transactions.date &lt;span style="color:#66d9ef">BETWEEN&lt;/span> &lt;span style="color:#e6db74">&amp;#39;2023-01-01&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">AND&lt;/span> &lt;span style="color:#e6db74">&amp;#39;2023-12-31&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>From a high level, in order to execute this statement the database will filter for the rows that we need, grab the data we need from those rows, and return the unique ones. That seems simple enough for a database as long as the &lt;code>date&lt;/code> column is indexed. However, the important part to consider is what the database needs to do to ensure all the data returned is unique. The database would need to keep all that data in memory someplace and use CPU time to sort these columns then remove the duplicates. Without the inclusion of a unique index, the sort will take time because there&amp;rsquo;s no guarantee that each column is unique.&lt;/p></description></item><item><title>TIL: MySQL Transaction Isolation Levels</title><link>//www.icepicky.com/blog/til-mysql-transaction-isolation-levels/</link><pubDate>Mon, 21 Aug 2023 16:00:23 -0600</pubDate><guid>//www.icepicky.com/blog/til-mysql-transaction-isolation-levels/</guid><description>&lt;p>Today I learned about MySQL transaction isolation levels.&lt;/p>
&lt;p>I was trying to debug issues where concurrent processes didn&amp;rsquo;t seem to be locking rows in the database correctly. A simplified version of the offending code could look something like this (comments added for those unfamiliar with Rails):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Reader: Assume the record we&amp;#39;re processing is not processed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># Query for the row with ID 123 for table some_active_record_classes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>some_active_record_class &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">SomeActiveRecordClass&lt;/span>&lt;span style="color:#f92672">.&lt;/span>where(id: &lt;span style="color:#ae81ff">123&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>first
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ActiveRecord&lt;/span>&lt;span style="color:#f92672">::&lt;/span>&lt;span style="color:#66d9ef">Base&lt;/span>&lt;span style="color:#f92672">.&lt;/span>transaction &lt;span style="color:#66d9ef">do&lt;/span> &lt;span style="color:#75715e"># Open a database transaction&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Query for associated data from another table processed_items&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> processed_items &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">ProcessedItem&lt;/span>&lt;span style="color:#f92672">.&lt;/span>where(&lt;span style="color:#e6db74">foreign_key&lt;/span>: some_active_record_class&lt;span style="color:#f92672">.&lt;/span>id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Lock the row with ID 123&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> some_active_record_class&lt;span style="color:#f92672">.&lt;/span>lock!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Requery the database for ID 123 to ensure we have the most up to date data after locking&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> some_active_record_class&lt;span style="color:#f92672">.&lt;/span>reload!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Early exit if the record is processed&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> some_active_record_class&lt;span style="color:#f92672">.&lt;/span>processed &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Simulate long running logic by waiting for 5 seconds&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">5&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Update the DB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> some_active_record_class&lt;span style="color:#f92672">.&lt;/span>update!(&lt;span style="color:#e6db74">processed&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>, &lt;span style="color:#e6db74">processed_count&lt;/span>: processed_items&lt;span style="color:#f92672">.&lt;/span>size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">end&lt;/span> &lt;span style="color:#75715e"># Release the lock, commit, and close the transaction&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>When running that code concurrently, you&amp;rsquo;d expect that only one process would do the updates and the other process(es) would exit immediately after grabbing the lock. However, we were seeing that all processes would update the database. Originally we thought the problem was that we weren&amp;rsquo;t opening a lock at all or we weren&amp;rsquo;t opening the lock correctly. We were correct on one point of the hypothesis: we were opening a lock but the logic to open it was incorrect.&lt;/p></description></item></channel></rss>