<!doctype html><html lang=en-US><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Jose Ibarra &#183; TIL: MySQL Transaction Isolation Levels</title>
<meta name=description content="Jose Ibarra is a staff software engineer at Bonusly and MCS and BS Computer Science graduate from Arizona State University. He previously worked at Gusto."><meta property="og:description" content="Jose Ibarra is a staff software engineer at Bonusly and MCS and BS Computer Science graduate from Arizona State University. He previously worked at Gusto."><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=referrer content="always"><meta name=googlebot content="index,follow,snippet,archive"><link rel=stylesheet href=//www.icepicky.com/hugo-theme-console/css/terminal-0.7.4.min.css><link rel=stylesheet href=//www.icepicky.com/hugo-theme-console/css/animate-4.1.1.min.css><link rel=stylesheet href=//www.icepicky.com/hugo-theme-console/css/console.css><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script><script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><meta property="og:title" content="TIL: MySQL Transaction Isolation Levels"><meta property="og:description" content="Jose Ibarra is a staff software engineer at Bonusly and MCS and BS Computer Science graduate from Arizona State University. He previously worked at Gusto."><meta property="og:type" content="article"><meta property="og:url" content="//www.icepicky.com/blog/til-mysql-transaction-isolation-levels/"><meta property="article:published_time" content="2023-08-21T16:00:23-06:00"><meta name=twitter:title content="TIL: MySQL Transaction Isolation Levels"><meta name=twitter:description content="Today I learned about MySQL transaction isolation levels.
I was trying to debug issues where concurrent processes didn&rsquo;t seem to be locking rows in the database correctly. A simplified version of the offending code could look something like this (comments added for those unfamiliar with Rails):
# Reader: Assume the record we're processing is not processed
# Query for the row with ID 123 for table some_active_record_classes
some_active_record_class = SomeActiveRecordClass.where(id: 123).first

ActiveRecord::Base.transaction do # Open a database transaction
  # Query for associated data from another table processed_items
  processed_items = ProcessedItem.where(foreign_key: some_active_record_class.id)

  # Lock the row with ID 123
  some_active_record_class.lock!

  # Requery the database for ID 123 to ensure we have the most up to date data after locking
  some_active_record_class.reload!

  # Early exit if the record is processed
  return if some_active_record_class.processed == true

  # Simulate long running logic by waiting for 5 seconds
  sleep(5)

  # Update the DB 
  some_active_record_class.update!(processed: true, processed_count: processed_items.size)
end # Release the lock, commit, and close the transaction
When running that code concurrently, you&rsquo;d expect that only one process would do the updates and the other process(es) would exit immediately after grabbing the lock. However, we were seeing that all processes would update the database. Originally we thought the problem was that we weren&rsquo;t opening a lock at all or we weren&rsquo;t opening the lock correctly. We were correct on one point of the hypothesis: we were opening a lock but the logic to open it was incorrect."></head><body class=terminal><div class=container><div class=terminal-nav><header class=terminal-logo><div class="logo terminal-prompt"><a href=//www.icepicky.com/ class=no-style>Jose Ibarra
</a>:~#
<a href=//www.icepicky.com/blog>blog</a>
/
<a href=//www.icepicky.com/blog/til-mysql-transaction-isolation-levels>til-mysql-transaction-isolation-levels</a>
/</div></header><nav class=terminal-menu><ul vocab="https://schema.org/" typeof="BreadcrumbList"><li property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" href=//www.icepicky.com/resume/><span property="name">resume/</span></a>
<meta property="position" content="1"></li><li property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" href=//www.icepicky.com/projects/><span property="name">projects/</span></a>
<meta property="position" content="2"></li><li property="itemListElement" typeof="ListItem"><a property="item" typeof="WebPage" href=//www.icepicky.com/blog/><span property="name">blog/</span></a>
<meta property="position" content="3"></li></ul></nav></div></div><div class=container><h1>TIL: MySQL Transaction Isolation Levels</h1><p>Today I learned about MySQL transaction isolation levels.</p><p>I was trying to debug issues where concurrent processes didn&rsquo;t seem to be locking rows in the database correctly. A simplified version of the offending code could look something like this (comments added for those unfamiliar with Rails):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#75715e># Reader: Assume the record we&#39;re processing is not processed</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Query for the row with ID 123 for table some_active_record_classes</span>
</span></span><span style=display:flex><span>some_active_record_class <span style=color:#f92672>=</span> <span style=color:#66d9ef>SomeActiveRecordClass</span><span style=color:#f92672>.</span>where(id: <span style=color:#ae81ff>123</span>)<span style=color:#f92672>.</span>first
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ActiveRecord</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Base</span><span style=color:#f92672>.</span>transaction <span style=color:#66d9ef>do</span> <span style=color:#75715e># Open a database transaction</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Query for associated data from another table processed_items</span>
</span></span><span style=display:flex><span>  processed_items <span style=color:#f92672>=</span> <span style=color:#66d9ef>ProcessedItem</span><span style=color:#f92672>.</span>where(<span style=color:#e6db74>foreign_key</span>: some_active_record_class<span style=color:#f92672>.</span>id)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Lock the row with ID 123</span>
</span></span><span style=display:flex><span>  some_active_record_class<span style=color:#f92672>.</span>lock!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Requery the database for ID 123 to ensure we have the most up to date data after locking</span>
</span></span><span style=display:flex><span>  some_active_record_class<span style=color:#f92672>.</span>reload!
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Early exit if the record is processed</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>if</span> some_active_record_class<span style=color:#f92672>.</span>processed <span style=color:#f92672>==</span> <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Simulate long running logic by waiting for 5 seconds</span>
</span></span><span style=display:flex><span>  sleep(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Update the DB </span>
</span></span><span style=display:flex><span>  some_active_record_class<span style=color:#f92672>.</span>update!(<span style=color:#e6db74>processed</span>: <span style=color:#66d9ef>true</span>, <span style=color:#e6db74>processed_count</span>: processed_items<span style=color:#f92672>.</span>size)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span> <span style=color:#75715e># Release the lock, commit, and close the transaction</span>
</span></span></code></pre></div><p>When running that code concurrently, you&rsquo;d expect that only one process would do the updates and the other process(es) would exit immediately after grabbing the lock. However, we were seeing that all processes would update the database. Originally we thought the problem was that we weren&rsquo;t opening a lock at all or we weren&rsquo;t opening the lock correctly. We were correct on one point of the hypothesis: we were opening a lock but the logic to open it was incorrect.</p><p>It turns out that MySQL uses <a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html target=_blank rel=noopener>transaction isolation levels</a> to ensure reads to the database are consistent for a transaction. By default, InnoDB in MySQL uses <code>REPEATABLE READ</code> as the isolation level. <code>REPEATABLE READ</code> <a href=https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read target=_blank rel=noopener>will ensure all queries within a transaction are repeatable</a> . That means all queries within a transaction will use the same snapshot as the first database read.</p><p>In our code, immediately after opening the transaction we query the database via <code>processed_items = ProcessedItem.where(foreign_key: some_active_record_class.id)</code>. That means that all other queries afterwards will use the data from this point in time. Importantly, this means that <code>some_active_record_class.reload!</code> may not always contain the data updated in another process.</p><p>This mistake was easy to make because it&rsquo;s easy to assume that you&rsquo;ll always query against the latest version of the database but that&rsquo;s not true for transactions in MySQL (and maybe other databases).</p><p>To resolve this, you could set your the isolation level for your transaction to one that always reads to a fresh snapshot (like <code>READ COMMITTED</code>) or you could set the default for the whole database to a different isolation level. We wouldn&rsquo;t consider the second approach since it affected the whole application. We were also wary about using <code>READ COMMITTED</code> in general because we were unsure of the side effects of using <code>READ COMMITTED</code> in long running code with many database reads. It seems like <code>READ COMMITTED</code> is generally safe because it uses locks to ensure consistency but thought <code>REPEATABLE READ</code> was likely a sensible default that we should try to use if possible. Side note: we would definitely not use <code>READ UNCOMMITTED</code> because it could use an old version of a row for a read.</p><p>Our solution ended up changing the code to lock immediately after opening the transaction. This would ensure processes would only ever use the snapshot of the time of the lock and would prevent stale data from being read. In Rails, the update would look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#75715e># ... beginning of method</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>ActiveRecord</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Base</span><span style=color:#f92672>.</span>transaction <span style=color:#66d9ef>do</span> <span style=color:#75715e># Open a database transaction</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># Immediately lock the row with ID 123</span>
</span></span><span style=display:flex><span>  some_active_record_class<span style=color:#f92672>.</span>lock!
</span></span><span style=display:flex><span>  <span style=color:#75715e># ... rest of method</span>
</span></span></code></pre></div><p>Or in one line that opens a transaction and immediately locks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=color:#75715e># ... beginning of method</span>
</span></span><span style=display:flex><span>some_active_record_class<span style=color:#f92672>.</span>with_lock <span style=color:#66d9ef>do</span> <span style=color:#75715e># Open a database transaction and lock the row</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e># ... rest of method</span>
</span></span></code></pre></div><div class=footer>2018-2025 Jose Ibarra</div></div></body></html>